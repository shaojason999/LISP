(defun mergesort (n numbers)
	(if (<= n 1)
		(return-from mergesort numbers)
	)
	(let ((leng 0)(leng2 0)(list1 nil)(list2 nil))
		(setf leng (floor n 2))
		(setf leng2 (+ (floor n 2)(mod n 2)))
		(setf list1 (mergesort leng (nthcdr leng2 (reverse numbers))))
		(setf list2 (mergesort leng2 (nthcdr leng numbers)))
		(setf numbers nil)
		(do ()
			((or (= leng 0)(= leng2 0))
				(if (= leng 0)
					(dolist (x list2)
						(setf numbers (cons x numbers))
					)
					(dolist (x list1)
						(setf numbers (cons x numbers))
					)
				)
				(setf numbers (reverse numbers))
			)
			(if (<= (car list1)(car list2))
				(progn
					(setf numbers (cons (car list1) numbers))
					(setf leng (- leng 1))
					(setf list1 (cdr list1))
				)
				(progn
					(setf numbers (cons (car list2) numbers))
					(setf leng2 (- leng2 1))
					(setf list2 (cdr list2))
				)
			)
		)
	)
	(return-from mergesort numbers)
)

; main function
(let ((n(read))(numbers))
	(setf numbers
		(do ((i 0 (+ i 1))(tmp nil))
			((>= i n)(reverse tmp))
			(setf tmp (cons (read) tmp))
		)
	)
	(format t "~{~A ~}~%" (mergesort n numbers))
)
